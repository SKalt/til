<!doctype html><html><head><meta charset=utf-8><title>Today I Learned</title><link rel=stylesheet href=https://skalt.github.io/til/critical.min.31ad46bcf2679dac23a81f48b7ead9b8f05c1c77fe86709a56fcce62f2ee6107.css><style>@import "https://skalt.github.io/til/syntax-light.min.cf596d35510d6f4d08d1eec88d3d2374b3ba785ef2c68eb605930d31b93576a5.css";@media(prefers-color-scheme:dark){@import "https://skalt.github.io/til/syntax-dark.min.aa68da46c4e748d1db4b8300bf7e282aaa0befd767ada0dcc34734e9ac4e0d51.css"}</style><script src=https://skalt.github.io/til/copy_on_click.3e911aeaa98e4d249246dac78aeae0701f095f2f31738c7f930a823f012b4c2b.js integrity="sha256-PpEa6qmOTSSSRtrHiurgcB8JXy8xc4x/kwqCPwErTCs=" defer></script></head><body><header><h1><a href=https://skalt.github.io/til/>Today I Learned</a></h1><nav><a href=https://skalt.github.io/til/tags>tags</a>
<a href=https://skalt.github.io/til/search>search</a>
<a href=https://github.com/skalt/til><img alt=repo title=repo src=https://skalt.github.io/til/icon_gh.512c0dbb601adf88d85cdd317f632f04c74f76183e9dd30c331272d46a59aa13.svg></a></nav></header><main><h1><a href=https://skalt.github.io/til/2024>2024</a>/<span>07</span>/05</h1><div><a href=https://skalt.github.io/til/tags/python>python</a></div><p>That Python mangles class attributes named like <code>__name</code>:</p><blockquote><p>Python mangles these names with the class name: if class <code>Foo</code> has an attribute named <code>__a</code>, it cannot be accessed by <code>Foo.__a</code>.
(An insistent user could still gain access by calling <code>Foo._Foo__a</code>.)
Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed.</p><p>Note: there is some controversy about the use of <code>__names</code> (see below).</p><p>&ndash; <a href=https://peps.python.org/pep-0008/#method-names-and-instance-variables>https://peps.python.org/pep-0008/#method-names-and-instance-variables</a></p></blockquote><blockquote><h4 id=designing-for-inheritance><a href=https://peps.python.org/pep-0008/#designing-for-inheritance>Designing for Inheritance</a></h4><p>Always decide whether a class’s methods and instance variables
(collectively: “attributes”) should be public or non-public. If in
doubt, choose non-public; it’s easier to make it public later than to
make a public attribute non-public.</p><p>Public attributes are those that you expect unrelated clients of your
class to use, with your commitment to avoid backwards incompatible
changes. Non-public attributes are those that are not intended to be
used by third parties; you make no guarantees that non-public
attributes won’t change or even be removed.</p><p>We don’t use the term “private” here, since no attribute is really
private in Python (without a generally unnecessary amount of work).</p><p>Another category of attributes are those that are part of the
“subclass API” (often called “protected” in other languages). Some
classes are designed to be inherited from, either to extend or modify
aspects of the class’s behavior. When designing such a class, take
care to make explicit decisions about which attributes are public,
which are part of the subclass API, and which are truly only to be
used by your base class.</p><p>With this in mind, here are the Pythonic guidelines:</p><ul><li><p>Public attributes should have no leading underscores.</p></li><li><p>If your public attribute name collides with a reserved keyword,
append a single trailing underscore to your attribute name. This is
preferable to an abbreviation or corrupted spelling. (However,
notwithstanding this rule, ‘cls’ is the preferred spelling for any
variable or argument which is known to be a class, especially the
first argument to a class method.)</p><p>Note 1: See the argument name recommendation above for class methods.</p></li><li><p>For simple public data attributes, it is best to expose just the
attribute name, without complicated accessor/mutator methods. Keep
in mind that Python provides an easy path to future enhancement,
should you find that a simple data attribute needs to grow
functional behavior. In that case, use properties to hide
functional implementation behind simple data attribute access
syntax.</p><p>Note 1: Try to keep the functional behavior side-effect free,
although side-effects such as caching are generally fine.</p><p>Note 2: Avoid using properties for computationally expensive
operations; the attribute notation makes the caller believe that
access is (relatively) cheap.</p></li><li><p>If your class is intended to be subclassed, and you have attributes
that you do not want subclasses to use, consider naming them with
double leading underscores and no trailing underscores. This
invokes Python’s name mangling algorithm, where the name of the
class is mangled into the attribute name. This helps avoid
attribute name collisions should subclasses inadvertently contain
attributes with the same name.</p><p>Note 1: Note that only the simple class name is used in the mangled
name, so if a subclass chooses both the same class name and attribute
name, you can still get name collisions.</p><p>Note 2: Name mangling can make certain uses, such as debugging and
<code>__getattr__()</code>, less convenient. However the name mangling
algorithm is well documented and easy to perform manually.</p><p>Note 3: Not everyone likes name mangling. Try to balance the
need to avoid accidental name clashes with potential use by
advanced callers.</p></li></ul><p>&ndash; <a href=https://peps.python.org/pep-0008/#designing-for-inheritance>https://peps.python.org/pep-0008/#designing-for-inheritance</a></p></blockquote></main><footer><span>© 2022-2022 CC BY-NC-SA 4.0</span></footer></body></html>