<!doctype html><html><head><meta charset=utf-8><title>Today I Learned</title><link rel=stylesheet href=https://skalt.github.io/til/critical.min.594b5b7a363d42cef2053010611ce4d2364196b08b295f8bf7199f9406b595e4.css></head><body><header><h1><a href=https://skalt.github.io/til/>Today I Learned</a></h1><nav><a href=https://skalt.github.io/til/tags>tags</a>
<a href=https://skalt.github.io/til/search>search</a>
<a href=https://github.com/skalt/til><img alt=repo title=repo src=https://skalt.github.io/til/icon_gh.512c0dbb601adf88d85cdd317f632f04c74f76183e9dd30c331272d46a59aa13.svg></a></nav></header><main><h1><a href=https://skalt.github.io/til/2023>2023</a>/<span>05</span>/29</h1><div><a href=https://skalt.github.io/til/tags/haskell>haskell</a></div><p>During some research on build systems, I began re-reading Build Systems a la Carte (<a href=https://github.com/snowleopard/build>repo</a>, <a href=https://www.cambridge.org/core/services/aop-cambridge-core/content/view/097CE52C750E69BD16B78C318754C7A4/S0956796820000088a.pdf/build-systems-a-la-carte-theory-and-practice.pdf>paper</a>).
I found the Haskell even more confusing than I remembered, so I set out to translate the Haskell types to Typescript, Rust, and other type systems I know.
When I got into the translation, I realized I only know enough to get the <em>vibe</em> of what Haskell code&rsquo;s saying :/.</p><p>The following are my notes on the 2021 open-source update to <em><a href=https://learnyouahaskell.github.io/types-and-typeclasses.html>Learn You A Haskell for Great Good</a></em>.</p><h2 id=starting-out>Starting out</h2><p><a href=https://learnyouahaskell.github.io/starting-out.html#an-intro-to-lists>https://learnyouahaskell.github.io/starting-out.html#an-intro-to-lists</a></p><p>What is the underlying datatype of a list? A linked list? Growable <code>Vec&lt;T></code>?</p><blockquote><p><code>++</code>
<code>:</code></p></blockquote><p>I already need a language server for figuring out operator definitions.</p><p>List comprehension syntax:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span>[ output var <span style=color:#f92672>|</span> var <span style=color:#f92672>&lt;-</span> inputSet]
</span></span><span style=display:flex><span><span style=color:#75715e>-- ^^^^^^^^^ </span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- the output function</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- also valid:</span>
</span></span><span style=display:flex><span>[ output var <span style=color:#f92672>|</span> var <span style=color:#f92672>&lt;-</span> inputSet, filterFn var, otherFilterFn var]
</span></span><span style=display:flex><span><span style=color:#75715e>-- also valid:</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>triangles</span> <span style=color:#f92672>=</span> [ (a,b,c) <span style=color:#f92672>|</span> c <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>], b <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>], a <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>] ]
</span></span></code></pre></div><p>Lists are homogenous, tuples can be heterogenous.</p><p>Range syntax seems to be the same as Rust.</p><h2 id=types--typeclasseshttpslearnyouahaskellgithubiotypes-and-typeclasseshtml><a href=https://learnyouahaskell.github.io/types-and-typeclasses.html>Types & Typeclasses</a></h2><blockquote><p>The <code>[Char]</code> type is synonymous with <code>String</code></p></blockquote><blockquote><pre tabindex=0><code>-- function type declaration
addThree :: Int -&gt; Int -&gt; Int -&gt; Int  
addThree x y z = x + y + z
-- fn definition
</code></pre></blockquote><p>Looks like functions are <a href=https://en.wikipedia.org/wiki/Currying>curried</a>.</p><p>Fun fact: Haskell was named after <a href=https://en.wikipedia.org/wiki/Haskell_Curry>Haskell Curry</a></p><blockquote><p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes.</p></blockquote><p>So like a typescript <code>interface</code> or a rust <code>trait</code></p><blockquote><p>Everything before the => symbol is called a class constraint.</p></blockquote><h2 id=syntax-in-functionshttpslearnyouahaskellgithubiosyntax-in-functionshtml><a href=https://learnyouahaskell.github.io/syntax-in-functions.html>Syntax in Functions</a></h2><p>Looks like hitting an un-handled branch of pattern matching throws an exception.
There are probably lints for such omissions.</p><p>Looks like <code>_</code> is used as the ignored variable.</p><blockquote><p>Guards are indicated by pipes that follow a function&rsquo;s name and its parameters. Usually, they&rsquo;re indented a bit to the right and lined up. A guard is basically a boolean expression. If it evaluates to True, then the corresponding function body is used. If it evaluates to False, checking drops through to the next guard and so on.</p></blockquote><p>Neat!</p><blockquote><p><code>where</code> bindings are a syntactic construct that let you bind to variables at the end of a function and the whole function can see them, including all the guards. <code>let</code> bindings let you bind to variables anywhere and are expressions themselves, but are very local, so they don&rsquo;t span across guards.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>-- x == 2</span>
</span></span></code></pre></div><blockquote><p>If we want to bind to several variables inline [&mldr;] we can separate them with semicolons.</p><pre tabindex=0><code>(let a = 100; b = 200; c = 300 in a*b*c, let foo=&#34;Hey &#34;; bar = &#34;there!&#34; in foo ++ bar)  
-- (6000000,&#34;Hey there!&#34;)
</code></pre></blockquote><p><code>case</code> expressions seem to be directly analogous to rust&rsquo;s <code>match</code> expressions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>case</span> expression <span style=color:#66d9ef>of</span> pattern <span style=color:#f92672>-&gt;</span> result  
</span></span><span style=display:flex><span>                   pattern <span style=color:#f92672>-&gt;</span> result  
</span></span><span style=display:flex><span>                   pattern <span style=color:#f92672>-&gt;</span> result  
</span></span><span style=display:flex><span>                   <span style=color:#f92672>...</span>
</span></span></code></pre></div><h2 id=higher-order-functionshttpslearnyouahaskellgithubiohigher-order-functionshtml><a href=https://learnyouahaskell.github.io/higher-order-functions.html>Higher order functions</a></h2><blockquote><p>Infix functions can also be partially applied by using sections. To section an infix function, simply surround it with parentheses and only supply a parameter on one side. That creates a function that takes one parameter and then applies it to the side that&rsquo;s missing an operand.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#a6e22e>divideByTen</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Floating</span> a) <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> a  
</span></span><span style=display:flex><span><span style=color:#a6e22e>divideByTen</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>/</span><span style=color:#ae81ff>10</span>)  
</span></span></code></pre></div></blockquote><p>&ldquo;lambdas&rdquo; = anonymous fns; written like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#75715e>--  v starting \</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>\</span>arg <span style=color:#f92672>-&gt;</span> result expr)
</span></span><span style=display:flex><span><span style=color:#75715e>-- ^                   ^ always parenthesized</span>
</span></span></code></pre></div><blockquote><p>[Haskell does] function composition with the . function, which is defined like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span>   (<span style=color:#f92672>.</span>) <span style=color:#f92672>::</span> (b <span style=color:#f92672>-&gt;</span> c) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> c  
</span></span><span style=display:flex><span>   f <span style=color:#f92672>.</span> g <span style=color:#f92672>=</span> <span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> f (g x)
</span></span></code></pre></div></blockquote><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span>(<span style=color:#f92672>$</span>) <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> b  
</span></span><span style=display:flex><span><span style=color:#a6e22e>f</span> <span style=color:#f92672>$</span> x <span style=color:#f92672>=</span> f x
</span></span></code></pre></div><p>Whereas normal function application (putting a space between two things) has a really high precedence, the <code>$</code> function has the lowest precedence. Function application with a space is left-associative (so <code>f a b c</code> is the same as <code>((f a) b) c))</code>, function application with <code>$</code> is right-associative. &mldr; Most of the time, <code>$</code>&rsquo;s a convenience function so that we don&rsquo;t have to write so many parentheses.
When a <code>$</code> is encountered, the expression on its right is applied as the parameter to the function on its left. How about <code>sqrt 3 + 4 + 9</code>? This adds together 9, 4 and the square root of 3. If we want to get the square root of 3 + 4 + 9, we&rsquo;d have to write <code>sqrt (3 + 4 + 9)</code> or if we use <code>$</code> we can write it as <code>sqrt $ 3 + 4 + 9</code> because <code>$</code> has the lowest precedence of any operator. That&rsquo;s why you can imagine a <code>$</code> being sort of the equivalent of writing an opening parenthesis and then writing a closing one on the far right side of the expression.</p></blockquote><p>^ this clears up a <em>lot</em>!</p><h2 id=moduleshttpslearnyouahaskellgithubiomoduleshtml><a href=https://learnyouahaskell.github.io/modules.html>Modules</a></h2><p>Note: the <code>Prelude</code> module is imported by default.
Note: module paths are separated by <code>.</code>s, e.g. <code>Data.List</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.List (<span style=color:#a6e22e>nub</span>, <span style=color:#a6e22e>sort</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.List <span style=color:#66d9ef>hiding</span> (<span style=color:#a6e22e>nub</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#66d9ef>qualified</span> Data.Map
</span></span><span style=display:flex><span><span style=color:#75715e>-- if we want to reference Data.Map&#39;s filter function, we have to</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- do `Data.Map.filter`</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#66d9ef>qualified</span> Data.Map <span style=color:#66d9ef>as</span> M <span style=color:#75715e>-- `M.filter`</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>module</span> ModName ( <span style=color:#75715e>-- must be same name as file.hs? MUST be capitalized</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exported</span>
</span></span><span style=display:flex><span>  , <span style=color:#a6e22e>fn</span>
</span></span><span style=display:flex><span>  , <span style=color:#a6e22e>names</span>
</span></span><span style=display:flex><span>  , <span style=color:#66d9ef>Thing</span>(<span style=color:#f92672>..</span>) <span style=color:#75715e>-- all the value constructors for Thing</span>
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>where</span>
</span></span></code></pre></div><p>Multi-module groups are directories of <code>ModName.hs</code> files, imported like <code>import GroupName.ModName</code>.</p><h2 id=making-our-own-types-and-typeclasses>making our own types and typeclasses</h2><blockquote><p>if we add deriving (Show) at the end of a data declaration, Haskell automagically makes that type part of the Show typeclass.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Person</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Person</span> { firstName <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>  
</span></span><span style=display:flex><span>                     , lastName <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>  
</span></span><span style=display:flex><span>                     , age <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span>  
</span></span><span style=display:flex><span>                     , height <span style=color:#f92672>::</span> <span style=color:#66d9ef>Float</span>  
</span></span><span style=display:flex><span>                     , phoneNumber <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>  
</span></span><span style=display:flex><span>                     , flavor <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>  
</span></span><span style=display:flex><span>                     } <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)
</span></span></code></pre></div></blockquote><blockquote><p>type constructors can take types as parameters to produce new types</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Maybe</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Just</span> a
</span></span><span style=display:flex><span><span style=color:#75715e>--    type ^ parameter</span>
</span></span></code></pre></div></blockquote><blockquote><p>A type can be made an instance of a typeclass if it supports that behavior. Example: the <code>Int</code> type is an instance of the <code>Eq</code> typeclass because the <code>Eq</code> typeclass defines behavior for stuff that can be equated.</p><p>&ndash; <a href=https://learnyouahaskell.github.io/making-our-own-types-and-typeclasses.html#derived-instances>derived instances</a></p></blockquote><blockquote><p>When I talk about <strong>concrete types</strong> I mean like fully applied types</p></blockquote><p>So concrete types don&rsquo;t have any free type parameters, but type constructors may have further free type parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Eq</span> equatable <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>^ this is how to define a typeclass, noting that <code>equatable</code> is a type parameter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Eq</span> a) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Num</span> a <span style=color:#66d9ef>where</span>  
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Eq</span> (<span style=color:#66d9ef>Maybe</span> m) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>^ defining instances / implementations of a typeclass.</p><blockquote><p>the <code>Functor</code> typeclass, which is basically for things that can be mapped over. &mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#66d9ef>where</span>  
</span></span><span style=display:flex><span>  fmap <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b
</span></span></code></pre></div><p>the f is not a concrete type (a type that a value can hold, like Int, Bool or Maybe String), but a type constructor that takes one type parameter.</p></blockquote><hr><p>This is enough for me to read further, so I&rsquo;m stopping for now.</p></main><footer><span>Â© 2022-2022 CC BY-NC-SA 4.0</span></footer></body></html>