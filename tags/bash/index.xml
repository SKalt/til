<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Bash on Today I Learned</title><link>https://skalt.github.io/til/tags/bash/</link><description>Recent content in Bash on Today I Learned</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>CC BY-NC-SA 4.0</copyright><atom:link href="https://skalt.github.io/til/tags/bash/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://skalt.github.io/til/2021/09/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2021/09/15/</guid><description>&lt;p>That you &lt;em>can&lt;/em>, technically, write inline comments in bash. Specifically, you have to put the comments in a subshell:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> abc &lt;span class="sb">`&lt;/span>&lt;span class="c1">#put your comment here` \&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> def &lt;span class="sb">`&lt;/span>&lt;span class="c1">#another chance for a comment` \&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> xyz etc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>^ from &lt;a href="https://stackoverflow.com/a/23872003/6571327">https://stackoverflow.com/a/23872003/6571327&lt;/a>&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2021/10/04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2021/10/04/</guid><description>&lt;p>that different versions of &lt;code>sort(1)&lt;/code> have different sorting presets.
For example, on ubuntu 20.04 vs debian buster, &lt;code>sort&lt;/code> will swap the order of how it sorts &lt;code>_&lt;/code>s.
These differences can be resolved by passing &lt;code>--unique --dictionary-order --stable&lt;/code>.&lt;/p>
&lt;p>Bonus: &lt;code>-h/--human-numeric-sort&lt;/code> can sort SI suffixes.&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2021/10/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2021/10/12/</guid><description>&lt;p>about the shell &lt;code>until&lt;/code> keyword, which is equivalent to &lt;code>while !&lt;/code>.&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2021/10/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2021/10/28/</guid><description>&lt;p>That you can detect the terminal you&amp;rsquo;re running in (including vscode) by checking the value of &lt;code>&amp;quot;${TERM_PROGRAM:-}&amp;quot;&lt;/code>.
The VS Code integrated termial always has a &lt;code>$TERM_PROGRAM&lt;/code> of &lt;code>vscode&lt;/code>.&lt;/p>
&lt;p>Source: &lt;a href="https://stackoverflow.com/a/59231654/6571327">https://stackoverflow.com/a/59231654/6571327&lt;/a>&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/04/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/04/11/</guid><description>&lt;p>You can use &lt;code>journalctl -u ${service_name}.service --since ${time:-today}&lt;/code> to view the logs of a systemd service: &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs">https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs&lt;/a>&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/05/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/05/10/</guid><description>&lt;p>That you can call &lt;code>time(1)&lt;/code> to time how long a shell command takes, like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="p">;&lt;/span> &lt;span class="nb">time&lt;/span> terraform fmt -write&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> -recursive .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># terraform fmt -write=true -recursive . 0.10s user 0.23s system 24% cpu 1.377 total&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://skalt.github.io/til/2022/07/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/07/02/</guid><description>&lt;p>That you can unescape newlines with &lt;code>printf &amp;quot;%b&amp;quot; 'escaped\nstring'&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">escaped&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;a\nb&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34;%b&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$escaped&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># b&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://skalt.github.io/til/2022/07/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/07/29/</guid><description>&lt;p>that in bash and zsh, you can put a newline in a variable like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">newline&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">$&amp;#39;\n&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">newline&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;lt;&amp;lt;&amp;lt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>learned from: &lt;a href="https://stackoverflow.com/a/4456399/6571327">https://stackoverflow.com/a/4456399/6571327&lt;/a>&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/08/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/08/24/</guid><description>&lt;p>that you can &lt;code>lsblk&lt;/code> to list the block devices that the OS knows about without sudo.&lt;/p>
&lt;p>that you can &lt;code>sudo growpart&lt;/code> to increase a partition size without restarting the machine.&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/08/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/08/29/</guid><description>&lt;p>That you can list the listening ports on a UNIX machine using &lt;code>sudo lsof -i -P -n | grep LISTEN&lt;/code>&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/10/03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/10/03/</guid><description>&lt;p>That you can write &lt;code>&amp;gt;&amp;amp; 1&lt;/code> and it still redirects to stdout!
example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">f&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;ok&amp;#34;&lt;/span> &amp;gt;&lt;span class="p">&amp;amp;&lt;/span>2&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f 2&amp;gt;&lt;span class="p">&amp;amp;&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> grep ok
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://skalt.github.io/til/2022/10/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/10/11/</guid><description>&lt;p>That &lt;code>terraform plan -detailed-exitcode&lt;/code> exists: 0 means no diff, 1 means error, 2 means a diff exists.&lt;/p>
&lt;p>Also, that you can print the source code of a bash function like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">print_fn_src&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="nb">declare&lt;/span> -f &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://skalt.github.io/til/2022/10/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/10/18/</guid><description>&lt;p>That BSD &lt;code>arch&lt;/code> command found on Macs also supports a &lt;code>-${arch}&lt;/code> flag for running universal binaries.&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/10/23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/10/23/</guid><description>&lt;p>That ARIA stands for Accessible Rich Internet Applications!
See &lt;a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA&lt;/a>&lt;/p>
&lt;hr>
&lt;p>That in linux &lt;code>ls(1)&lt;/code> uses the environment variable &lt;code>LS_COLORS&lt;/code> to determine the colors in which the filenames are to be displayed.
Also, that linux specifies a &lt;code>dir_colors(5)&lt;/code> configuration file format for &lt;code>dircolors(1)&lt;/code>, which exports &lt;code>LS_COLORS&lt;/code>&lt;/p>
&lt;p>See &lt;a href="https://man7.org/linux/man-pages/man5/dir_colors.5.html">https://man7.org/linux/man-pages/man5/dir_colors.5.html&lt;/a>&lt;/p>
&lt;hr>
&lt;p>That nix is complicated, which is exactly what my prior research told me.&lt;/p>
&lt;p>On one hand, it is &lt;strong>AWESOME&lt;/strong> to cd into a project and watch &lt;a href="">&lt;code>direnv&lt;/code>&lt;/a> automatically spawn a development shell with all the fixings.
On the other, the nix ecosystem is bewildering.
I read through a few articles:&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2022/10/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2022/10/24/</guid><description>&lt;p>That you can list all addresses in terraform state by running&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">terraform state list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Docs at &lt;a href="https://developer.hashicorp.com/terraform/cli/commands/state/list">https://developer.hashicorp.com/terraform/cli/commands/state/list&lt;/a>&lt;/p>
&lt;hr>
&lt;p>Also, that &lt;code>compgen -v&lt;/code> is a function, at least on Mac zsh.
Apparently in zsh &lt;code>compgen -v&lt;/code> calls something like&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> var_name in &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="p">(k)parameters[@]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">printf&lt;/span> &lt;span class="s1">&amp;#39;%s\n&amp;#39;&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$var_name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>which is the first time I&amp;rsquo;ve seen that kind of shell syntax.
It generates a &lt;code>bad substitution&lt;/code> message in bash 3.2, so I can only assume it&amp;rsquo;s zsh-specific.&lt;/p></description></item><item><title/><link>https://skalt.github.io/til/2023/05/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skalt.github.io/til/2023/05/30/</guid><description>&lt;p>That there&amp;rsquo;s a Linux command to do sql-like &lt;code>JOIN&lt;/code>s of lines in files, possibly based on a field in each line: &lt;a href="https://linux.die.net/man/1/join">&lt;code>join(1)&lt;/code>&lt;/a>&lt;/p></description></item></channel></rss>